<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dearest Friend identifier-JP</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Montserrat', sans-serif;
      }
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(circle at top, #111 0%, #000 100%);
        color: #fff;
        height: 100vh;
        position: relative;
      }
      /* Fluid effect container */
      .container {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 50;
        pointer-events: none;
        width: 100%;
        height: 100%;
      }
      #fluid {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      /* Original code styles below */
      .cursor-trail {
        position: absolute;
        width: 10px;
        height: 10px;
        background: radial-gradient(circle, #ff00e0, #00ffe0);
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        animation: trailFadeOut 1s forwards;
        z-index: 1000;
      }
      @keyframes trailFadeOut {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.5);
        }
      }
      @keyframes typing {
        from {
          width: 0;
        }
        to {
          width: 100%;
        }
      }
      @keyframes blink {
        0%,
        100% {
          border-color: transparent;
        }
        50% {
          border-color: #00ffe0;
        }
      }
      #login-form h2 {
        margin-bottom: 20px;
        font-size: 20px;
        color: #00ffe0;
        text-shadow: 0 0 8px #00ffe0;
        white-space: nowrap;
        overflow: hidden;
        border-right: 2px solid;
        width: 0;
        animation: typing 2s steps(20) 1s forwards, blink 0.8s step-end infinite;
      }
      #login-form {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 380px;
        padding: 35px;
        text-align: center;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        backdrop-filter: blur(20px);
        box-shadow: 0 0 20px #00ffe0, 0 0 60px #00ffe0;
        animation: pulse 3s infinite alternate;
        z-index: 10;
      }
      #login-form input {
        width: 100%;
        padding: 12px;
        margin: 15px 0;
        border: none;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 16px;
        outline: none;
      }
      #login-form button {
        padding: 12px 25px;
        background: linear-gradient(135deg, #00ffc3, #ff00e0);
        border: none;
        border-radius: 50px;
        font-size: 16px;
        font-weight: bold;
        color: #fff;
        cursor: pointer;
        box-shadow: 0 0 10px #00ffc3, 0 0 20px #ff00e0;
        transition: transform 0.3s ease;
      }
      #login-form button:hover {
        transform: scale(1.1);
        box-shadow: 0 0 20px #00ffc3, 0 0 40px #ff00e0;
      }
      .particle {
        position: fixed;
        top: -20px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: radial-gradient(circle, #ff00e0, #00ffe0);
        animation: fall 6s linear forwards;
        pointer-events: none;
        z-index: 1;
      }
      .particle::after {
        content: '★';
        font-size: 12px;
        color: #fff;
        position: absolute;
        top: -2px;
        left: -2px;
      }
      @keyframes fall {
        to {
          transform: translateY(110vh) rotate(360deg);
          opacity: 0;
        }
      }
      #overlay {
        position: fixed;
        inset: 0;
        background: #000;
        color: lime;
        font-family: monospace;
        font-size: 2rem;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 9999;
      }
      .countdown {
        font-size: 4rem;
        animation: flicker 0.5s steps(2, end) infinite;
      }
      @keyframes flicker {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.2;
        }
      }
      #matrix {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: black;
        z-index: 999;
        display: none;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #final-message {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        text-align: center;
        font-size: 32px;
        color: red;
        text-shadow: 0 0 10px red;
        z-index: 1001;
        display: none;
        word-wrap: break-word;
      }
      #retry-btn {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 16px;
        background: transparent;
        color: white;
        border: 2px solid #0f0;
        border-radius: 10px;
        cursor: pointer;
        display: none;
        position: relative;
        z-index: 10002;
      }
      .you-did-it {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 28px;
        padding: 20px 40px;
        color: #00f0ff;
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid #00f0ff;
        border-radius: 10px;
        box-shadow: 0 0 10px #00f0ff, 0 0 40px #00f0ff;
        white-space: nowrap;
        overflow: hidden;
        border-right: 2px solid #00f0ff;
        width: 0;
        animation: typing2 2.5s steps(30, end) forwards, blink-caret 0.75s step-end infinite,
          glowflicker 2s infinite;
        z-index: 10000;
        display: none;
      }
      @keyframes typing2 {
        from {
          width: 0;
        }
        to {
          width: 320px;
        }
      }
      @keyframes blink-caret {
        from,
        to {
          border-color: transparent;
        }
        50% {
          border-color: #00f0ff;
        }
      }
      @keyframes glowflicker {
        0%,
        100% {
          text-shadow: 0 0 5px #00f0ff, 0 0 20px #00f0ff;
        }
        50% {
          text-shadow: 0 0 2px #00f0ff, 0 0 5px #00f0ff;
        }
      }
      #starfield {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 9999;
      }
      #analyzing-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        color: #0f0;
        font-family: monospace;
        font-size: 2rem;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 9999;
        position: relative;
      }
      #analyzing-screen canvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: -1;
      }
      #overlay-container {
        position: relative;
        z-index: 10000;
      }
      #analyzing-text {
        position: relative;
        z-index: 10001;
      }
      #overlay {
        background-color: #0a0a0a;
        background-image: linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
          linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
        background-size: 10px 10px;
        animation: fade-in-out 5s infinite;
      }
      @keyframes fade-in-out {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.8;
        }
        100% {
          opacity: 1;
        }
      }
      #analyzing-screen {
        background-color: #0a0a0a;
        background-image: radial-gradient(circle, #0f0 1px, transparent 1px),
          radial-gradient(circle, #0f0 1px, transparent 1px);
        background-size: 20px 20px;
        background-position: 0 0, 10px 10px;
        animation: pulsing-dots 2s infinite;
      }
      @keyframes pulsing-dots {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="fluid"></canvas>
    </div>
    <audio id="success-sound" src="birthday.mp3" preload="auto"></audio>
    <audio id="error-sound" src="error.mp3" preload="auto"></audio>

    <form id="login-form">
      <h2>Who is your dearest friend?</h2>
      <input type="text" id="love-name" placeholder="Dearest friend" />
      <button id="submit-btn">Verify answer</button>
    </form>

    <div id="overlay">
      <div id="overlay-container">
        <div class="countdown" id="countdown">3</div>
        <div id="final-message">ACCESS DENIED. SYSTEM BREACHED.</div>
        <button id="retry-btn" onclick="location.reload()">Retry</button>
      </div>
      <div id="matrix"><canvas id="matrix-canvas"></canvas></div>
    </div>

    <div id="analyzing-screen">
      <canvas id="analyzing-canvas"></canvas>
      <div id="analyzing-text">Analyzing Input...</div>
    </div>

    <div class="you-did-it" id="success-msg">✨ You did it, J.P. ✨</div>
    <canvas id="starfield"></canvas>

    <script>
      (function () {
        const canvas = document.getElementById('fluid');
        if (!canvas) {
          console.error('Canvas element not found.');
          return;
        }
        // Fluid effect configuration
        const config = {
          SIM_RESOLUTION: 128,
          DYE_RESOLUTION: 1440,
          CAPTURE_RESOLUTION: 512,
          DENSITY_DISSIPATION: 3.5,
          VELOCITY_DISSIPATION: 2,
          PRESSURE: 0.1,
          PRESSURE_ITERATIONS: 20,
          CURL: 3,
          SPLAT_RADIUS: 0.2,
          SPLAT_FORCE: 6000,
          SHADING: true,
          COLOR_UPDATE_SPEED: 10,
          BACK_COLOR: { r: 0.5, g: 0, b: 0 },
          TRANSPARENT: true,
        };
        //... [आपका पूरा WebGL fluid code यहाँ है] ...
        function pointerPrototype() {
          this.id = -1;
          this.texcoordX = 0;
          this.texcoordY = 0;
          this.prevTexcoordX = 0;
          this.prevTexcoordY = 0;
          this.deltaX = 0;
          this.deltaY = 0;
          this.down = false;
          this.moved = false;
          this.color = [0, 0, 0];
        }
        let pointers = [new pointerPrototype()];
        const { gl, ext } = getWebGLContext(canvas);
        if (!ext.supportLinearFiltering) {
          config.DYE_RESOLUTION = 256;
          config.SHADING = false;
        }
        function getWebGLContext(canvas) {
          const params = {
            alpha: true,
            depth: false,
            stencil: false,
            antialias: false,
            preserveDrawingBuffer: false,
          };
          let gl = canvas.getContext('webgl2', params);
          const isWebGL2 = !!gl;
          if (!isWebGL2) {
            gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);
          }
          let halfFloat;
          let supportLinearFiltering;
          if (isWebGL2) {
            gl.getExtension('EXT_color_buffer_float');
            supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
          } else {
            halfFloat = gl.getExtension('OES_texture_half_float');
            supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
          }
          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;
          let formatRGBA;
          let formatRG;
          let formatR;
          if (isWebGL2) {
            formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
            formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
            formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
          } else {
            formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
            formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
            formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
          }
          return {
            gl,
            ext: {
              formatRGBA,
              formatRG,
              formatR,
              halfFloatTexType,
              supportLinearFiltering,
            },
          };
        }
        function getSupportedFormat(gl, internalFormat, format, type) {
          if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
            switch (internalFormat) {
              case gl.R16F:
                return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
              case gl.RG16F:
                return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
              default:
                return null;
            }
          }
          return { internalFormat, format };
        }
        function supportRenderTextureFormat(gl, internalFormat, format, type) {
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);
          const fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
          return status === gl.FRAMEBUFFER_COMPLETE;
        }
        class Material {
          constructor(vertexShader, fragmentShaderSource) {
            this.vertexShader = vertexShader;
            this.fragmentShaderSource = fragmentShaderSource;
            this.programs = [];
            this.activeProgram = null;
            this.uniforms = [];
          }
          setKeywords(keywords) {
            let hash = 0;
            for (let i = 0; i < keywords.length; i++) {
              hash += hashCode(keywords[i]);
            }
            let program = this.programs[hash];
            if (program == null) {
              let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);
              program = createProgram(this.vertexShader, fragmentShader);
              this.programs[hash] = program;
            }
            if (program === this.activeProgram) return;
            this.uniforms = getUniforms(program);
            this.activeProgram = program;
          }
          bind() {
            gl.useProgram(this.activeProgram);
          }
        }
        class Program {
          constructor(vertexShader, fragmentShader) {
            this.uniforms = {};
            this.program = createProgram(vertexShader, fragmentShader);
            this.uniforms = getUniforms(this.program);
          }
          bind() {
            gl.useProgram(this.program);
          }
        }
        function createProgram(vertexShader, fragmentShader) {
          let program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.trace(gl.getProgramInfoLog(program));
          }
          return program;
        }
        function getUniforms(program) {
          let uniforms = [];
          let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
          for (let i = 0; i < uniformCount; i++) {
            let uniformName = gl.getActiveUniform(program, i).name;
            uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
          }
          return uniforms;
        }
        function compileShader(type, source, keywords) {
          source = addKeywords(source, keywords);
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.trace(gl.getShaderInfoLog(shader));
          }
          return shader;
        }
        function addKeywords(source, keywords) {
          if (!keywords) return source;
          let keywordsString = '';
          keywords.forEach((keyword) => {
            keywordsString += '#define ' + keyword + '\n';
          });
          return keywordsString + source;
        }
        const baseVertexShader = compileShader(
          gl.VERTEX_SHADER,
          `
            precision highp float;
            attribute vec2 aPosition;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform vec2 texelSize;
            void main () {
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
          `
        );
        const copyShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision mediump float;
            precision mediump sampler2D;
            varying highp vec2 vUv;
            uniform sampler2D uTexture;
            void main () {
                gl_FragColor = texture2D(uTexture, vUv);
            }
          `
        );
        const clearShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision mediump float;
            precision mediump sampler2D;
            varying highp vec2 vUv;
            uniform sampler2D uTexture;
            uniform float value;
            void main () {
                gl_FragColor = value * texture2D(uTexture, vUv);
            }
          `
        );
        const displayShaderSource = `
          precision highp float;
          precision highp sampler2D;
          varying vec2 vUv;
          varying vec2 vL;
          varying vec2 vR;
          varying vec2 vT;
          varying vec2 vB;
          uniform sampler2D uTexture;
          uniform sampler2D uDithering;
          uniform vec2 ditherScale;
          uniform vec2 texelSize;
          vec3 linearToGamma (vec3 color) {
              color = max(color, vec3(0));
              return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));
          }
          void main () {
              vec3 c = texture2D(uTexture, vUv).rgb;
              #ifdef SHADING
                  vec3 lc = texture2D(uTexture, vL).rgb;
                  vec3 rc = texture2D(uTexture, vR).rgb;
                  vec3 tc = texture2D(uTexture, vT).rgb;
                  vec3 bc = texture2D(uTexture, vB).rgb;
                  float dx = length(rc) - length(lc);
                  float dy = length(tc) - length(bc);
                  vec3 n = normalize(vec3(dx, dy, length(texelSize)));
                  vec3 l = vec3(0.0, 0.0, 1.0);
                  float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
                  c *= diffuse;
              #endif
              float a = max(c.r, max(c.g, c.b));
              gl_FragColor = vec4(c, a);
          }
        `;
        const splatShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision highp float;
            precision highp sampler2D;
            varying vec2 vUv;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;
            void main () {
                vec2 p = vUv - point.xy;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                gl_FragColor = vec4(base + splat, 1.0);
            }
          `
        );
        const advectionShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision highp float;
            precision highp sampler2D;
            varying vec2 vUv;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform vec2 dyeTexelSize;
            uniform float dt;
            uniform float dissipation;
            vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
                vec2 st = uv / tsize - 0.5;
                vec2 iuv = floor(st);
                vec2 fuv = fract(st);
                vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
                vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
                vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
                vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);
                return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
            }
            void main () {
                #ifdef MANUAL_FILTERING
                    vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
                    vec4 result = bilerp(uSource, coord, dyeTexelSize);
                #else
                    vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                    vec4 result = texture2D(uSource, coord);
                #endif
                float decay = 1.0 + dissipation * dt;
                gl_FragColor = result / decay;
            }
          `,
          ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']
        );
        const divergenceShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision mediump float;
            precision mediump sampler2D;
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uVelocity;
            void main () {
                float L = texture2D(uVelocity, vL).x;
                float R = texture2D(uVelocity, vR).x;
                float T = texture2D(uVelocity, vT).y;
                float B = texture2D(uVelocity, vB).y;
                vec2 C = texture2D(uVelocity, vUv).xy;
                if (vL.x < 0.0) { L = -C.x; }
                if (vR.x > 1.0) { R = -C.x; }
                if (vT.y > 1.0) { T = -C.y; }
                if (vB.y < 0.0) { B = -C.y; }
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
          `
        );
        const curlShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision mediump float;
            precision mediump sampler2D;
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uVelocity;
            void main () {
                float L = texture2D(uVelocity, vL).y;
                float R = texture2D(uVelocity, vR).y;
                float T = texture2D(uVelocity, vT).x;
                float B = texture2D(uVelocity, vB).x;
                float vorticity = R - L - T + B;
                gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
            }
          `
        );
        const vorticityShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision highp float;
            precision highp sampler2D;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;
            uniform sampler2D uCurl;
            uniform float curl;
            uniform float dt;
            void main () {
                float L = texture2D(uCurl, vL).x;
                float R = texture2D(uCurl, vR).x;
                float T = texture2D(uCurl, vT).x;
                float B = texture2D(uCurl, vB).x;
                float C = texture2D(uCurl, vUv).x;
                vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
                force /= length(force) + 0.0001;
                force *= curl * C;
                force.y *= -1.0;
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity += force * dt;
                velocity = min(max(velocity, -1000.0), 1000.0);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
          `
        );
        const pressureShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision mediump float;
            precision mediump sampler2D;
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;
            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                float C = texture2D(uPressure, vUv).x;
                float divergence = texture2D(uDivergence, vUv).x;
                float pressure = (L + R + B + T - divergence) * 0.25;
                gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
            }
          `
        );
        const gradientSubtractShader = compileShader(
          gl.FRAGMENT_SHADER,
          `
            precision mediump float;
            precision mediump sampler2D;
            varying highp vec2 vUv;
            varying highp vec2 vL;
            varying highp vec2 vR;
            varying highp vec2 vT;
            varying highp vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;
            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity.xy -= vec2(R - L, T - B);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
          `
        );
        const blit = (() => {
          gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
          gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(0);
          return (target, clear = false) => {
            if (target == null) {
              gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            } else {
              gl.viewport(0, 0, target.width, target.height);
              gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            }
            if (clear) {
              gl.clearColor(0.0, 0.0, 0.0, 1.0);
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
          };
        })();
        let dye, velocity, divergence, curl, pressure;
        const copyProgram = new Program(baseVertexShader, copyShader);
        const clearProgram = new Program(baseVertexShader, clearShader);
        const splatProgram = new Program(baseVertexShader, splatShader);
        const advectionProgram = new Program(baseVertexShader, advectionShader);
        const divergenceProgram = new Program(baseVertexShader, divergenceShader);
        const curlProgram = new Program(baseVertexShader, curlShader);
        const vorticityProgram = new Program(baseVertexShader, vorticityShader);
        const pressureProgram = new Program(baseVertexShader, pressureShader);
        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);
        const displayMaterial = new Material(baseVertexShader, displayShaderSource);
        function initFramebuffers() {
          let simRes = getResolution(config.SIM_RESOLUTION);
          let dyeRes = getResolution(config.DYE_RESOLUTION);
          const texType = ext.halfFloatTexType;
          const rgba = ext.formatRGBA;
          const rg = ext.formatRG;
          const r = ext.formatR;
          const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
          gl.disable(gl.BLEND);
          if (!dye) {
            dye = createDoubleFBO(
              dyeRes.width,
              dyeRes.height,
              rgba.internalFormat,
              rgba.format,
              texType,
              filtering
            );
          } else {
            dye = resizeDoubleFBO(
              dye,
              dyeRes.width,
              dyeRes.height,
              rgba.internalFormat,
              rgba.format,
              texType,
              filtering
            );
          }
          if (!velocity) {
            velocity = createDoubleFBO(
              simRes.width,
              simRes.height,
              rg.internalFormat,
              rg.format,
              texType,
              filtering
            );
          } else {
            velocity = resizeDoubleFBO(
              velocity,
              simRes.width,
              simRes.height,
              rg.internalFormat,
              rg.format,
              texType,
              filtering
            );
          }
          divergence = createFBO(
            simRes.width,
            simRes.height,
            r.internalFormat,
            r.format,
            texType,
            gl.NEAREST
          );
          curl = createFBO(
            simRes.width,
            simRes.height,
            r.internalFormat,
            r.format,
            texType,
            gl.NEAREST
          );
          pressure = createDoubleFBO(
            simRes.width,
            simRes.height,
            r.internalFormat,
            r.format,
            texType,
            gl.NEAREST
          );
        }
        function createFBO(w, h, internalFormat, format, type, param) {
          gl.activeTexture(gl.TEXTURE0);
          let texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
          let fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.viewport(0, 0, w, h);
          gl.clear(gl.COLOR_BUFFER_BIT);
          let texelSizeX = 1.0 / w;
          let texelSizeY = 1.0 / h;
          return {
            texture,
            fbo,
            width: w,
            height: h,
            texelSizeX,
            texelSizeY,
            attach(id) {
              gl.activeTexture(gl.TEXTURE0 + id);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              return id;
            },
          };
        }
        function createDoubleFBO(w, h, internalFormat, format, type, param) {
          let fbo1 = createFBO(w, h, internalFormat, format, type, param);
          let fbo2 = createFBO(w, h, internalFormat, format, type, param);
          return {
            width: w,
            height: h,
            texelSizeX: fbo1.texelSizeX,
            texelSizeY: fbo1.texelSizeY,
            get read() {
              return fbo1;
            },
            set read(value) {
              fbo1 = value;
            },
            get write() {
              return fbo2;
            },
            set write(value) {
              fbo2 = value;
            },
            swap() {
              let temp = fbo1;
              fbo1 = fbo2;
              fbo2 = temp;
            },
          };
        }
        function resizeFBO(target, w, h, internalFormat, format, type, param) {
          let newFBO = createFBO(w, h, internalFormat, format, type, param);
          copyProgram.bind();
          gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
          blit(newFBO);
          return newFBO;
        }
        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {
          if (target.width === w && target.height === h) return target;
          target.read = resizeFBO(
            target.read,
            w,
            h,
            internalFormat,
            format,
            type,
            param
          );
          target.write = createFBO(w, h, internalFormat, format, type, param);
          target.width = w;
          target.height = h;
          target.texelSizeX = 1.0 / w;
          target.texelSizeY = 1.0 / h;
          return target;
        }
        function updateKeywords() {
          let displayKeywords = [];
          if (config.SHADING) displayKeywords.push('SHADING');
          displayMaterial.setKeywords(displayKeywords);
        }
        updateKeywords();
        initFramebuffers();
        let lastUpdateTime = Date.now();
        let colorUpdateTimer = 0.0;
        function updateFrame() {
          const dt = calcDeltaTime();
          if (resizeCanvas()) initFramebuffers();
          updateColors(dt);
          applyInputs();
          step(dt);
          render(null);
          requestAnimationFrame(updateFrame);
        }
        function calcDeltaTime() {
          let now = Date.now();
          let dt = (now - lastUpdateTime) / 1000;
          dt = Math.min(dt, 0.016666);
          lastUpdateTime = now;
          return dt;
        }
        function resizeCanvas() {
          let width = scaleByPixelRatio(canvas.clientWidth);
          let height = scaleByPixelRatio(canvas.clientHeight);
          if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            return true;
          }
          return false;
        }
        function updateColors(dt) {
          colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;
          if (colorUpdateTimer >= 1) {
            colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);
            pointers.forEach((p) => {
              p.color = generateColor();
            });
          }
        }
        function applyInputs() {
          pointers.forEach((p) => {
            if (p.moved) {
              p.moved = false;
              splatPointer(p);
            }
          });
        }
        function step(dt) {
          gl.disable(gl.BLEND);
          curlProgram.bind();
          gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
          gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
          blit(curl);
          vorticityProgram.bind();
          gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
          gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
          gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
          gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
          gl.uniform1f(vorticityProgram.uniforms.dt, dt);
          blit(velocity.write);
          velocity.swap();
          divergenceProgram.bind();
          gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
          gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
          blit(divergence);
          clearProgram.bind();
          gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
          gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
          blit(pressure.write);
          pressure.swap();
          pressureProgram.bind();
          gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
          gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
          for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
            gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
            blit(pressure.write);
            pressure.swap();
          }
          gradienSubtractProgram.bind();
          gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
          gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
          gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
          blit(velocity.write);
          velocity.swap();
          advectionProgram.bind();
          gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
          if (!ext.supportLinearFiltering) {
            gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
          }
          let velocityId = velocity.read.attach(0);
          gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
          gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
          gl.uniform1f(advectionProgram.uniforms.dt, dt);
          gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
          blit(velocity.write);
          velocity.swap();
          if (!ext.supportLinearFiltering) {
            gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
          }
          gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
          gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
          gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
          blit(dye.write);
          dye.swap();
        }
        function render(target) {
          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          gl.enable(gl.BLEND);
          drawDisplay(target);
        }
        function drawDisplay(target) {
          let width = target == null ? gl.drawingBufferWidth : target.width;
          let height = target == null ? gl.drawingBufferHeight : target.height;
          displayMaterial.bind();
          if (config.SHADING) {
            gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);
          }
          gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
          blit(target);
        }
        function splatPointer(pointer) {
          let dx = pointer.deltaX * config.SPLAT_FORCE;
          let dy = pointer.deltaY * config.SPLAT_FORCE;
          splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);
        }
        function clickSplat(pointer) {
          const color = generateColor();
          color.r *= 10.0;
          color.g *= 10.0;
          color.b *= 10.0;
          let dx = 10 * (Math.random() - 0.5);
          let dy = 30 * (Math.random() - 0.5);
          splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);
        }
        function splat(x, y, dx, dy, color) {
          splatProgram.bind();
          gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
          gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
          gl.uniform2f(splatProgram.uniforms.point, x, y);
          gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);
          gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));
          blit(velocity.write);
          velocity.swap();
          gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
          gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
          blit(dye.write);
          dye.swap();
        }
        function correctRadius(radius) {
          let aspectRatio = canvas.width / canvas.height;
          if (aspectRatio > 1) radius *= aspectRatio;
          return radius;
        }
        function updatePointerDownData(pointer, id, posX, posY) {
          pointer.id = id;
          pointer.down = true;
          pointer.moved = false;
          pointer.texcoordX = posX / canvas.width;
          pointer.texcoordY = 1.0 - posY / canvas.height;
          pointer.prevTexcoordX = pointer.texcoordX;
          pointer.prevTexcoordY = pointer.texcoordY;
          pointer.deltaX = 0;
          pointer.deltaY = 0;
          pointer.color = generateColor();
        }
        function updatePointerMoveData(pointer, posX, posY, color) {
          pointer.prevTexcoordX = pointer.texcoordX;
          pointer.prevTexcoordY = pointer.texcoordY;
          pointer.texcoordX = posX / canvas.width;
          pointer.texcoordY = 1.0 - posY / canvas.height;
          pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);
          pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);
          pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;
          pointer.color = color;
        }
        function updatePointerUpData(pointer) {
          pointer.down = false;
        }
        function correctDeltaX(delta) {
          let aspectRatio = canvas.width / canvas.height;
          if (aspectRatio < 1) delta *= aspectRatio;
          return delta;
        }
        function correctDeltaY(delta) {
          let aspectRatio = canvas.width / canvas.height;
          if (aspectRatio > 1) delta /= aspectRatio;
          return delta;
        }
        function generateColor() {
          let c = HSVtoRGB(Math.random(), 1.0, 1.0);
          c.r *= 0.15;
          c.g *= 0.15;
          c.b *= 0.15;
          return c;
        }
        function HSVtoRGB(h, s, v) {
          let r, g, b, i, f, p, q, t;
          i = Math.floor(h * 6);
          f = h * 6 - i;
          p = v * (1 - s);
          q = v * (1 - f * s);
          t = v * (1 - (1 - f) * s);
          switch (i % 6) {
            case 0:
              r = v;
              g = t;
              b = p;
              break;
            case 1:
              r = q;
              g = v;
              b = p;
              break;
            case 2:
              r = p;
              g = v;
              b = t;
              break;
            case 3:
              r = p;
              g = q;
              b = v;
              break;
            case 4:
              r = t;
              g = p;
              b = v;
              break;
            case 5:
              r = v;
              g = p;
              b = q;
              break;
            default:
              break;
          }
          return { r, g, b };
        }
        function wrap(value, min, max) {
          const range = max - min;
          if (range === 0) return min;
          return ((value - min) % range) + min;
        }
        function getResolution(resolution) {
          let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
          if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;
          const min = Math.round(resolution);
          const max = Math.round(resolution * aspectRatio);
          if (gl.drawingBufferWidth > gl.drawingBufferHeight) {
            return { width: max, height: min };
          } else {
            return { width: min, height: max };
          }
        }
        function scaleByPixelRatio(input) {
          const pixelRatio = window.devicePixelRatio || 1;
          return Math.floor(input * pixelRatio);
        }
        function hashCode(s) {
          if (s.length === 0) return 0;
          let hash = 0;
          for (let i = 0; i < s.length; i++) {
            hash = (hash << 5) - hash + s.charCodeAt(i);
            hash |= 0;
          }
          return hash;
        }
        window.addEventListener('mousedown', (e) => {
          let pointer = pointers[0];
          let posX = scaleByPixelRatio(e.clientX);
          let posY = scaleByPixelRatio(e.clientY);
          updatePointerDownData(pointer, -1, posX, posY);
          clickSplat(pointer);
        });
        document.body.addEventListener('mousemove', function handleFirstMouseMove(e) {
          let pointer = pointers[0];
          let posX = scaleByPixelRatio(e.clientX);
          let posY = scaleByPixelRatio(e.clientY);
          let color = generateColor();
          updateFrame();
          updatePointerMoveData(pointer, posX, posY, color);
          document.body.removeEventListener('mousemove', handleFirstMouseMove);
        });
        window.addEventListener('mousemove', (e) => {
          let pointer = pointers[0];
          let posX = scaleByPixelRatio(e.clientX);
          let posY = scaleByPixelRatio(e.clientY);
          let color = pointer.color;
          updatePointerMoveData(pointer, posX, posY, color);
        });
        document.body.addEventListener('touchstart', function handleFirstTouchStart(e) {
          const touches = e.targetTouches;
          let pointer = pointers[0];
          for (let i = 0; i < touches.length; i++) {
            let posX = scaleByPixelRatio(touches[i].clientX);
            let posY = scaleByPixelRatio(touches[i].clientY);
            updateFrame();
            updatePointerDownData(pointer, touches[i].identifier, posX, posY);
          }
          document.body.removeEventListener('touchstart', handleFirstTouchStart);
        });
        window.addEventListener('touchstart', (e) => {
          const touches = e.targetTouches;
          let pointer = pointers[0];
          for (let i = 0; i < touches.length; i++) {
            let posX = scaleByPixelRatio(touches[i].clientX);
            let posY = scaleByPixelRatio(touches[i].clientY);
            updatePointerDownData(pointer, touches[i].identifier, posX, posY);
          }
        });
        window.addEventListener(
          'touchmove',
          (e) => {
            const touches = e.targetTouches;
            let pointer = pointers[0];
            for (let i = 0; i < touches.length; i++) {
              let posX = scaleByPixelRatio(touches[i].clientX);
              let posY = scaleByPixelRatio(touches[i].clientY);
              updatePointerMoveData(pointer, posX, posY, pointer.color);
            }
          },
          false
        );
        window.addEventListener('touchend', (e) => {
          const touches = e.changedTouches;
          let pointer = pointers[0];
          for (let i = 0; i < touches.length; i++) {
            updatePointerUpData(pointer);
          }
        });
        updateFrame();
      })();
    </script>
    <script>
      const successSound = document.getElementById('success-sound');
      const errorSound = document.getElementById('error-sound');
      const successMsg = document.getElementById('success-msg');
      const analyzingScreen = document.getElementById('analyzing-screen');
      const analyzingText = document.getElementById('analyzing-text');
      successMsg.style.display = 'none';

      const finalMessage = document.getElementById('final-message');
      const retryBtn = document.getElementById('retry-btn');

      document.getElementById('submit-btn').addEventListener('click', function (event) {
        event.preventDefault();
        const nameInput = document.getElementById('love-name').value.trim().toLowerCase();

        if (nameInput === 'ekanth') {
          document.getElementById('login-form').style.display = 'none';
          analyzingScreen.style.display = 'flex';

          successSound.play();

          typeText(analyzingText, 'Analyzing Input...', 50, () => {
            setTimeout(() => {
              analyzingText.textContent = 'ACCESS GRANTED';
            }, 1000); // ACCESS GRANTED duration 1 sec.

            setTimeout(() => {
              analyzingScreen.style.display = 'none';
              successMsg.style.display = 'block';
              initStars();

              setTimeout(() => {
                successMsg.style.transition = 'transform 1s ease, opacity 1s ease';
                successMsg.style.transform = 'translate(-50%, -50%) scale(2)';
                successMsg.style.opacity = '0';
              }, 4000);

              setTimeout(() => {
                window.location.href = 'text.html';
              }, 6000);
            }, 3000); // Total duration ko 3 seconds kar diya.
          });
        } else {
          errorSound.play();
          document.getElementById('login-form').style.display = 'none';
          document.getElementById('overlay').style.display = 'flex';
          let count = 3;
          const countdownEl = document.getElementById('countdown');
          const interval = setInterval(() => {
            count--;
            if (count > 0) {
              countdownEl.textContent = count;
            } else {
              clearInterval(interval);
              countdownEl.style.display = 'none';
              generateMatrixRain();

              setTimeout(() => {
                finalMessage.style.display = 'block';
                retryBtn.style.display = 'inline-block';
              }, 3000);
            }
          }, 1000);
        }
      });

      function typeText(element, text, speed, callback) {
        let i = 0;
        element.textContent = '';
        const interval = setInterval(() => {
          if (i < text.length) {
            element.textContent += text.charAt(i);
            i++;
          } else {
            clearInterval(interval);
            if (callback) callback();
          }
        }, speed);
      }

      function generateMatrixRain() {
        document.getElementById('matrix').style.display = 'block';
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const letters = '01★⚠#Δ$Ξ¥Ж%πΨ∇☢'.split('');
        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);
        const drops = Array(columns).fill(1);

        function draw() {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
          ctx.font = fontSize + 'px monospace';
          for (let i = 0; i < drops.length; i++) {
            const text = letters[Math.floor(Math.random() * letters.length)];
            ctx.fillText(text, i * fontSize, drops[i] * fontSize);
            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
              drops[i] = 0;
            }
            drops[i]++;
          }
        }
        setInterval(draw, 33);
      }

      function createParticle() {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        const size = Math.random() * 8 + 8;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        particle.style.left = Math.random() * 100 + 'vw';
        particle.style.animationDuration = Math.random() * 2 + 4 + 's';
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 6000);
      }
      setInterval(createParticle, 150);

      function initStars() {
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');
        let w, h;
        let stars = [];
        function init() {
          w = canvas.width = window.innerWidth;
          h = canvas.height = window.innerHeight;
          stars = [];
          for (let i = 0; i < 250; i++) {
            stars.push({
              x: Math.random() * w,
              y: Math.random() * h,
              z: Math.random() * w,
            });
          }
        }
        function animate() {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(0, 0, w, h);
          ctx.fillStyle = '#00f0ff';
          stars.forEach((star) => {
            star.z -= 3;
            if (star.z <= 0) star.z = w;
            const k = 128.0 / star.z;
            const x = (star.x - w / 2) * k + w / 2;
            const y = (star.y - h / 2) * k + h / 2;
            ctx.beginPath();
            ctx.arc(x, y, 1.2, 0, Math.PI * 2);
            ctx.fill();
          });
          requestAnimationFrame(animate);
        }
        init();
        animate();
        window.addEventListener('resize', init);
      }
    </script>
  </body>
</html>

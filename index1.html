<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WELCOME TO EKANTH'S WORLD</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background-color: black;
      color: #00ffcc;
      font-family: 'Courier New', Courier, monospace;
      overflow: hidden;
      position: relative; /* Add this to make z-index work correctly */
    }
    .scene {
      position: absolute;
      width: 100%;
      height: 100%;
      padding: 40px 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      opacity: 0;
      transition: opacity 1s ease;
    }
    .scene.active {
      opacity: 1;
      z-index: 2;
    }
    .ascii-art {
      width: 100%;
      margin-bottom: 20px;
      line-height: 1.3;
      display: flex;
      justify-content: center;
      align-items: center;
      transform: scale(0.6);
      transform-origin: top center;
    }
    .pulsing-text.override-flash {
      font-size: 22px;
      margin-top: 30px;
      animation: flashGlow 1s infinite alternate;
      color: #ff0033;
      text-shadow: 0 0 8px #ff0033, 0 0 15px #ff0033, 0 0 25px #ff0033;
    }
    .terminal-text {
      width: 100%;
      max-width: 720px;
      text-align: left;
      color: #00ff66;
      font-size: 16px;
      line-height: 1.4;
    }
    @keyframes flashGlow {
      0% { opacity: 0.5; text-shadow: 0 0 4px #ff0033; }
      100% { opacity: 1; text-shadow: 0 0 15px #ff0033, 0 0 30px #ff0033; }
    }
    @keyframes pulse {
      from { opacity: 0.5; }
      to { opacity: 1; }
    }

    /* === Scene 2 Styles === */
    #matrixCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      display: none;
    }
    .terminal {
      position: absolute;
      top: 5%;
      left: 5%;
      width: 90%;
      z-index: 2;
      font-size: 1.1rem;
      animation: crtFlicker 1.5s infinite alternate;
    }
    .photo-scan {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 150px;
      height: 180px;
      border: 2px solid #0f0;
      background: #111 url('https://via.placeholder.com/150x180?text=Scanning...') center/cover no-repeat;
      z-index: 3;
      box-shadow: 0 0 10px #0f0;
      display: none;
      overflow: hidden;
      animation: scanBorder 1s infinite alternate;
    }
    .photo-scan::before {
      content: "";
      position: absolute;
      width: 300px;
      height: 300px;
      top: -75px;
      left: -75px;
      border-radius: 50%;
      background: rgba(0, 255, 0, 0.1);
      box-shadow: 0 0 60px 30px rgba(0, 255, 0, 0.3);
      animation: pulse 2s infinite;
      z-index: -1;
    }
    .scanner-line {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: rgba(0, 255, 0, 0.6);
      box-shadow: 0 0 10px #0f0;
      animation: scanLine 2s linear infinite;
      z-index: 4;
    }
    .red-cross {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 150px;
      height: 180px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      color: red;
      background: rgba(0,0,0,0.6);
      z-index: 4;
      display: none;
    }
    .final-prompt, .button-group {
      display: none;
      opacity: 0;
      transition: opacity 1s ease;
    }
    .final-prompt {
      position: absolute;
      bottom: 20%;
      width: 100%;
      text-align: center;
      font-size: 1.5rem;
      color: #0ff;
    }
    .button-group {
      position: absolute;
      bottom: 10%;
      width: 100%;
      text-align: center;
    }
    .btn {
      display: inline-block;
      margin: 0 20px;
      padding: 12px 25px;
      font-size: 1.2rem;
      color: #0f0;
      border: 2px solid #0f0;
      background: transparent;
      cursor: pointer;
      text-shadow: 0 0 5px #0f0;
      transition: all 0.3s;
    }
    .btn:hover {
      background: #0f0;
      color: black;
      transform: scale(1.05) rotate(-1deg);
      filter: brightness(1.5);
    }
    @keyframes crtFlicker { 0% { opacity: 1; } 50% { opacity: 0.97; } 100% { opacity: 1; } }
    @keyframes scanBorder { from { box-shadow: 0 0 5px #0f0; } to { box-shadow: 0 0 20px #0f0; } }
    @keyframes scanLine { 0% { top: 0; } 100% { top: 100%; } }
    @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 0.2; } 50% { transform: scale(1.3); opacity: 0.4; } }
    .line-scan { color: #00ffcc; text-shadow: 0 0 5px #00ffcc; }
    .line-analyze { color: #99ff00; text-shadow: 0 0 5px #99ff00; }
    .line-fail { color: #ff0033; text-shadow: 0 0 8px #ff0033; }
    .line-warning { color: #ff9900; text-shadow: 0 0 6px #ff9900; }
    .line-purge { color: #66ffff; text-shadow: 0 0 5px #66ffff; }
    .line-erase { color: #cc99ff; text-shadow: 0 0 6px #cc99ff; }
    .line-recover { color: #33ccff; text-shadow: 0 0 5px #33ccff; }
    .line-search { color: #ffff66; text-shadow: 0 0 6px #ffff66; }
    .line-found { color: #00ff99; text-shadow: 0 0 8px #00ff99; font-weight: bold; }
    .line-creator { color: #00ffff; text-shadow: 0 0 6px #00ffff; font-weight: bold; }

    /* Cursor Trail */
    #trailCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 100;
      pointer-events: none;
    }

    /* ---- Wavy Background Styles ---- */
    .waves {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        --x: 50%;
        --y: 50%;
        /* z-index को -2 किया ताकि यह matrix से भी पीछे रहे */
        z-index: -2; 
        pointer-events: none;
    }
    .waves::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 0.5rem;
        height: 0.5rem;
        background: #160000;
        border-radius: 50%;
        transform: translate3d(calc(var(--x) - 50%), calc(var(--y) - 50%), 0);
        will-change: transform;
    }
    .waves-canvas {
        display: block;
        width: 100%;
        height: 100%;
    }
  </style>
</head>
<body>
  <div id="waves-container" class="waves">
    <canvas id="waves-canvas" class="waves-canvas"></canvas>
  </div>
  <div id="scene1" class="scene active">
    <div class="ascii-art">
<pre>
█▀ ▀█▀ ▄▀█ █▀█ ▀█▀ █ █▄░█ █▀▀     █▀ █▄█ █▀ ▀█▀ █▀▀ █▀▄▀█
▄█ ░█░ █▀█ █▀▄ ░█░ █ █░▀█ █▄█     ▄█ ░█░ ▄█ ░█░ ██▄ █░▀░█
</pre>
    </div>
    <div class="terminal-text" id="bootLines"></div>
    <div class="pulsing-text override-flash">OVERRIDE PROTOCOL INJECTED</div>
  </div>

  <canvas id="matrixCanvas"></canvas>
  <canvas id="trailCanvas"></canvas>
  <div id="mainInterface">
    <div class="photo-scan" id="photoBox">
      <div class="scanner-line"></div>
    </div>
    <div class="red-cross" id="redCross">❌</div>
    <div class="terminal" id="terminal"></div>
    <div class="final-prompt">A hidden identity protocol was found, left behind by Mr. Ekanth.<br>Do you wish to activate it?</div>
    <div class="button-group">
      <button class="btn" onclick="acceptProtocol()">YES</button>
      <button class="btn" id="noBtn" onmouseover="moveButton()">NO</button>
    </div>
  </div>

  <script>
    const bootLines = [
      "[BOOT] Initializing secure shell...",
      "[INFO] Performing hardware integrity checks...",
      "[OK] CPU cores online: 8x 3.6GHz",
      "[INFO] Memory map... OK",
      "[OK] System checksum verified",
      "[INFO] BIOS version: EK-X99 v3.1",
      "[SECURE] Injecting override protocol...",
      "[ACCESS] Authentication bypassed",
      "[INFO] Mounting encrypted drive...",
      "[NOTICE] Welcome back, Operator"
    ];
    const bootLinesEl = document.getElementById("bootLines");
    let index = 0;
    function showNextLine() {
      if (index < bootLines.length) {
        bootLinesEl.innerHTML += "&gt; " + bootLines[index] + "<br>";
        index++;
        setTimeout(showNextLine, 600);
      } else {
        setTimeout(() => {
          document.getElementById("scene1").classList.remove("active");
          document.getElementById("mainInterface").style.opacity = 1;
          document.getElementById("matrixCanvas").style.display = "block";
          startMatrix();
          typeLines();
        }, 1000);
      }
    }
    // setTimeout(showNextLine, 1000); // This is moved to DOMContentLoaded

    const canvas = document.getElementById("matrixCanvas");
    const ctx = canvas.getContext("2d");
    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;
    let chars = "アァイィウヴエカキクケコサシスセソタチツナニハヒフヘホマミムメモヤユヨラリルレロワンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split("");
    let fontSize = 14;
    let columns = Math.floor(w / fontSize);
    let drops = Array(columns).fill(1);
    function drawMatrix() {
      ctx.fillStyle = "rgba(0,0,0,0.05)";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#0f0";
      ctx.font = fontSize + "px monospace";
      for (let i = 0; i < drops.length; i++) {
        let text = chars[Math.floor(Math.random() * chars.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
        if (drops[i] * fontSize > h && Math.random() > 0.975) drops[i]++;
        drops[i]++;
      }
    }
    function startMatrix() {
      setInterval(drawMatrix, 50);
    }

    const lines = [
      "Scanning identity...",
      "Analyzing facial features...",
      "Verification failed.",
      "⚠️ Unauthorized individual detected.",
      "Purging temporary system cache...",
      "Erasing classified access logs...",
      "Attempting recovery protocol...",
      "Searching encrypted archives...",
      "Found: last backup identity protocol",
      "Creator: Mr. Ekanth"
    ];
    const lineClasses = [
      "line-scan", "line-analyze", "line-fail", "line-warning", "line-purge",
      "line-erase", "line-recover", "line-search", "line-found", "line-creator"
    ];
    let i = 0;
    function typeLines() {
      const term = document.getElementById("terminal");
      const photo = document.getElementById("photoBox");
      const redCross = document.getElementById("redCross");
      if (i < lines.length) {
        const line = document.createElement("div");
        line.className = lineClasses[i];
        line.textContent = "> " + lines[i];
        term.appendChild(line);
        if (i === 0) photo.style.display = "block";
        if (i === 2) redCross.style.display = "flex";
        if (i === 3) {
          setTimeout(() => {
            photo.style.display = "none";
            redCross.style.display = "none";
          }, 2000);
        }
        i++;
        setTimeout(typeLines, 1000);
      } else {
        setTimeout(() => {
          document.querySelector(".final-prompt").style.display = "block";
          document.querySelector(".button-group").style.display = "block";
          setTimeout(() => {
            document.querySelector(".final-prompt").style.opacity = 1;
            document.querySelector(".button-group").style.opacity = 1;
          }, 100);
        }, 1500);
      }
    }

    function acceptProtocol() {
      window.location.href = "2nd.html";
    }
    function moveButton() {
      const btn = document.getElementById("noBtn");
      const newX = Math.random() * 80 + 5;
      const newY = Math.random() * 60 + 10;
      btn.style.position = "absolute";
      btn.style.left = `${newX}%`;
      btn.style.top = `${newY}%`;
    }

    // Cursor Trail JavaScript (No changes needed)
    var trailCtx;
    var f;
    var pos = { x: 0, y: 0 };
    var trailLines = [];
    var E = {
        debug: true,
        friction: 0.5,
        trails: 20,
        size: 50,
        dampening: 0.25,
        tension: 0.98,
    };
    function SineWaveValue(e) {
        this.init(e || {});
    }
    SineWaveValue.prototype = {
        init: function (e) {
            this.phase = e.phase || 0;
            this.offset = e.offset || 0;
            this.frequency = e.frequency || 0.001;
            this.amplitude = e.amplitude || 1;
        },
        update: function () {
            this.phase += this.frequency;
            return this.offset + Math.sin(this.phase) * this.amplitude;
        },
        value: function () {
            return this.offset + Math.sin(this.phase) * this.amplitude;
        },
    };
    function Node() {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
    }
    function Line(e) {
        this.init(e || {});
    }
    Line.prototype = {
        init: function (e) {
            this.spring = e.spring + 0.1 * Math.random() - 0.02;
            this.friction = E.friction + 0.01 * Math.random() - 0.002;
            this.nodes = [];
            for (var n = 0; n < E.size; n++) {
                var t = new Node();
                t.x = pos.x;
                t.y = pos.y;
                this.nodes.push(t);
            }
        },
        update: function () {
            var e = this.spring, t = this.nodes[0];
            t.vx += (pos.x - t.x) * e;
            t.vy += (pos.y - t.y) * e;
            for (var n, i = 0, a = this.nodes.length; i < a; i++) {
                t = this.nodes[i];
                if (i > 0) {
                    n = this.nodes[i - 1];
                    t.vx += (n.x - t.x) * e;
                    t.vy += (n.y - t.y) * e;
                    t.vx += n.vx * E.dampening;
                    t.vy += n.vy * E.dampening;
                }
                t.vx *= this.friction;
                t.vy *= this.friction;
                t.x += t.vx;
                t.y += t.vy;
                e *= E.tension;
            }
        },
        draw: function () {
            var e, t, n = this.nodes[0].x, i = this.nodes[0].y;
            trailCtx.beginPath();
            trailCtx.moveTo(n, i);
            for (var a = 1, o = this.nodes.length - 2; a < o; a++) {
                e = this.nodes[a];
                t = this.nodes[a + 1];
                n = 0.5 * (e.x + t.x);
                i = 0.5 * (e.y + t.y);
                trailCtx.quadraticCurveTo(e.x, e.y, n, i);
            }
            e = this.nodes[a];
            t = this.nodes[a + 1];
            trailCtx.quadraticCurveTo(e.x, e.y, t.x, t.y);
            trailCtx.stroke();
            trailCtx.closePath();
        },
    };
    function updatePos(e) {
        if (e.touches) {
            pos.x = e.touches[0].pageX;
            pos.y = e.touches[0].pageY;
        } else {
            pos.x = e.clientX;
            pos.y = e.clientY;
        }
    }
    function setupLines() {
        trailLines = [];
        for (var i = 0; i < E.trails; i++) {
            trailLines.push(new Line({ spring: 0.4 + (i / E.trails) * 0.025 }));
        }
    }
    function render() {
        if (trailCtx.running) {
            trailCtx.globalCompositeOperation = 'source-over';
            trailCtx.clearRect(0, 0, trailCtx.canvas.width, trailCtx.canvas.height);
            trailCtx.globalCompositeOperation = 'lighter';
            trailCtx.strokeStyle = 'hsla(' + Math.round(f.update()) + ',50%,20%,0.8)';
            trailCtx.lineWidth = 3;
            for (var i = 0; i < E.trails; i++) {
                trailLines[i].update();
                trailLines[i].draw();
            }
            trailCtx.frame++;
            window.requestAnimationFrame(render);
        }
    }
    function resizeTrailCanvas() {
        const canvas = document.getElementById('trailCanvas');
        if (canvas) {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
    }
    function initCursorTrail() {
        const canvas = document.getElementById('trailCanvas');
        if (!canvas) {
          console.error('Trail canvas not found!');
          return;
        }
        trailCtx = canvas.getContext('2d');
        trailCtx.running = true;
        trailCtx.frame = 1;
        f = new SineWaveValue({
            phase: Math.random() * 2 * Math.PI,
            amplitude: 85,
            frequency: 0.0015,
            offset: 285,
        });
        document.addEventListener('mousemove', updatePos);
        document.addEventListener('touchmove', updatePos, { passive: false });
        document.addEventListener('touchstart', updatePos, { passive: false });
        window.addEventListener('resize', resizeTrailCanvas);
        window.addEventListener('focus', () => {
            if (!trailCtx.running) {
                trailCtx.running = true;
                render();
            }
        });
        window.addEventListener('blur', () => {
            trailCtx.running = false;
        });
        resizeTrailCanvas();
        setupLines();
        render();
    };

    // --- Wavy Background JS ---

    class Grad {
        constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
        dot2(x, y) { return this.x * x + this.y * y; }
    }
    class Noise {
        constructor(seed = 0) {
            this.grad3 = [
                new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),
                new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),
                new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)
            ];
            this.p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
                69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,
                203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74,
                165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105,
                92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,
                89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
                226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,
                182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,
                43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
                97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,
                107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
                138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
            ];
            this.perm = new Array(512);
            this.gradP = new Array(512);
            this.seed(seed);
        }
        seed(seed) {
            if (seed > 0 && seed < 1) seed *= 65536;
            seed = Math.floor(seed);
            if (seed < 256) seed |= seed << 8;
            for (let i = 0; i < 256; i++) {
                let v = (i & 1) ? (this.p[i] ^ (seed & 255)) : (this.p[i] ^ ((seed >> 8) & 255));
                this.perm[i] = this.perm[i + 256] = v;
                this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 12];
            }
        }
        fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        lerp(a, b, t) { return (1 - t) * a + t * b; }
        perlin2(x, y) {
            let X = Math.floor(x), Y = Math.floor(y);
            x -= X; y -= Y; X &= 255; Y &= 255;
            const n00 = this.gradP[X + this.perm[Y]].dot2(x, y);
            const n01 = this.gradP[X + this.perm[Y + 1]].dot2(x, y - 1);
            const n10 = this.gradP[X + 1 + this.perm[Y]].dot2(x - 1, y);
            const n11 = this.gradP[X + 1 + this.perm[Y + 1]].dot2(x - 1, y - 1);
            const u = this.fade(x);
            return this.lerp(
                this.lerp(n00, n10, u),
                this.lerp(n01, n11, u),
                this.fade(y)
            );
        }
    }

    function createWaves(config) {
        const container = document.getElementById("waves-container");
        const canvas = document.getElementById("waves-canvas");
        const ctx = canvas.getContext("2d");
        
        let bounding = { width: 0, height: 0, left: 0, top: 0 };
        let noise = new Noise(Math.random());
        let lines = [];
        let mouse = {
            x: -10, y: 0, lx: 0, ly: 0, sx: 0, sy: 0, v: 0, vs: 0, a: 0, set: false
        };
        let frameId = null;

        function setSize() {
            bounding = container.getBoundingClientRect();
            canvas.width = bounding.width;
            canvas.height = bounding.height;
        }
        function setLines() {
            const { width, height } = bounding;
            lines = [];
            const oWidth = width + 200, oHeight = height + 30;
            const { xGap, yGap } = config;
            const totalLines = Math.ceil(oWidth / xGap);
            const totalPoints = Math.ceil(oHeight / yGap);
            const xStart = (width - xGap * totalLines) / 2;
            const yStart = (height - yGap * totalPoints) / 2;
            for (let i = 0; i <= totalLines; i++) {
                const pts = [];
                for (let j = 0; j <= totalPoints; j++) {
                    pts.push({
                        x: xStart + xGap * i,
                        y: yStart + yGap * j,
                        wave: { x: 0, y: 0 },
                        cursor: { x: 0, y: 0, vx: 0, vy: 0 }
                    });
                }
                lines.push(pts);
            }
        }
        function movePoints(time) {
            const { waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove } = config;
            lines.forEach((pts) => {
                pts.forEach((p) => {
                    const move = noise.perlin2(
                        (p.x + time * waveSpeedX) * 0.002,
                        (p.y + time * waveSpeedY) * 0.0015
                    ) * 12;
                    p.wave.x = Math.cos(move) * waveAmpX;
                    p.wave.y = Math.sin(move) * waveAmpY;
                    const dx = p.x - mouse.sx, dy = p.y - mouse.sy;
                    const dist = Math.hypot(dx, dy), l = Math.max(175, mouse.vs);
                    if (dist < l) {
                        const s = 1 - dist / l;
                        const f = Math.cos(dist * 0.001) * s;
                        p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00065;
                        p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00065;
                    }
                    p.cursor.vx += (0 - p.cursor.x) * tension;
                    p.cursor.vy += (0 - p.cursor.y) * tension;
                    p.cursor.vx *= friction;
                    p.cursor.vy *= friction;
                    p.cursor.x += p.cursor.vx * 2;
                    p.cursor.y += p.cursor.vy * 2;
                    p.cursor.x = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.x));
                    p.cursor.y = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.y));
                });
            });
        }
        function moved(point, withCursor = true) {
            const x = point.x + point.wave.x + (withCursor ? point.cursor.x : 0);
            const y = point.y + point.wave.y + (withCursor ? point.cursor.y : 0);
            return { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };
        }
        function drawLines() {
            const { width, height } = bounding;
            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            ctx.strokeStyle = config.lineColor; 
            lines.forEach((points) => {
                let p1 = moved(points[0], false);
                ctx.moveTo(p1.x, p1.y);
                points.forEach((p, idx) => {
                    const isLast = idx === points.length - 1;
                    p1 = moved(p, !isLast);
                    const p2 = moved(points[idx + 1] || points[points.length - 1], !isLast);
                    ctx.lineTo(p1.x, p1.y);
                    if (isLast) ctx.moveTo(p2.x, p2.y);
                });
            });
            ctx.stroke();
        }
        function tick(t) {
            mouse.sx += (mouse.x - mouse.sx) * 0.1;
            mouse.sy += (mouse.y - mouse.sy) * 0.1;
            const dx = mouse.x - mouse.lx, dy = mouse.y - mouse.ly;
            const d = Math.hypot(dx, dy);
            mouse.v = d;
            mouse.vs += (d - mouse.vs) * 0.1;
            mouse.vs = Math.min(100, mouse.vs);
            mouse.lx = mouse.x; mouse.ly = mouse.y;
            mouse.a = Math.atan2(dy, dx);
            container.style.setProperty("--x", `${mouse.sx}px`);
            container.style.setProperty("--y", `${mouse.sy}px`);
            movePoints(t);
            drawLines();
            frameId = requestAnimationFrame(tick);
        }
        function onResize() {
            setSize();
            setLines();
        }
        function onMouseMove(e) { updateMouse(e.clientX, e.clientY); }
        function onTouchMove(e) {
            const touch = e.touches[0];
            updateMouse(touch.clientX, touch.clientY);
        }
        function updateMouse(x, y) {
            const b = bounding;
            mouse.x = x - b.left;
            mouse.y = y - b.top;
            if (!mouse.set) {
                mouse.sx = mouse.x; mouse.sy = mouse.y;
                mouse.lx = mouse.x; mouse.ly = mouse.y;
                mouse.set = true;
            }
        }
        
        setSize();
        setLines();
        frameId = requestAnimationFrame(tick);
        window.addEventListener("resize", onResize);
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("touchmove", onTouchMove, { passive: false });
        return () => {
            window.removeEventListener("resize", onResize);
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("touchmove", onTouchMove);
            cancelAnimationFrame(frameId);
        };
    }
    
    const neonColors = [
        "#00ffff", "#00ff99", "#ff00ff", "#ff66cc", "#ffff66"
    ];
    let currentColorIndex = 0;
    const waveConfig = {
        lineColor: neonColors[0],
        backgroundColor: "transparent",
        waveSpeedX: 0.0125,
        waveSpeedY: 0.005,
        waveAmpX: 32,
        waveAmpY: 16,
        xGap: 10,
        yGap: 32,
        friction: 0.925,
        tension: 0.005,
        maxCursorMove: 100
    };
    function changeLineColor() {
        currentColorIndex = (currentColorIndex + 1) % neonColors.length;
        waveConfig.lineColor = neonColors[currentColorIndex];
    }
    setInterval(changeLineColor, 2000);

    document.addEventListener('DOMContentLoaded', () => {
      showNextLine();
      initCursorTrail(); 
      createWaves(waveConfig);
    });
  </script>
</body>
</html>

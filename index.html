<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teleporting...to hell</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        /* Existing styles */
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Orbitron', sans-serif;
            color: #00ffcc;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            position: relative;
        }

        .grid-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(0, 255, 204, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 204, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: grid-move 20s linear infinite;
            z-index: 1;
        }

        @keyframes grid-move {
            from { background-position: 0 0; }
            to { background-position: 50px 50px; }
        }

        .portal-container {
            position: relative;
            width: 60vh;
            height: 60vh;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .spiral-wave {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: 0 0 80px #00aaff, inset 0 0 40px #00aaff;
            animation: portal-spin 20s linear infinite, glow-pulse 3s ease-in-out infinite alternate;
            background: radial-gradient(circle, rgba(0, 255, 204, 0.5) 0%, rgba(0, 255, 204, 0) 70%);
        }

        .spiral-wave::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 5px solid rgba(0, 255, 204, 0.8);
            border-radius: 50%;
            animation: wave-expand 3s ease-out infinite;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.8);
        }

        @keyframes portal-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes glow-pulse {
            from { box-shadow: 0 0 80px #00aaff; }
            to { box-shadow: 0 0 100px #00aaff; }
        }

        @keyframes wave-expand {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        
        .portal-content {
            z-index: 3;
            text-align: center;
            position: relative;
            top: 20vh;
        }
        
        .teleport-btn {
            background: linear-gradient(45deg, #00ffcc, #00aaff);
            border: none;
            color: black;
            padding: 15px 32px;
            font-size: 1.2em;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px #00ffcc;
        }

        .teleport-btn:hover {
            background: linear-gradient(45deg, #00aaff, #00ffcc);
            transform: scale(1.05);
            box-shadow: 0 0 25px #00aaff;
        }

        /* Verification Overlay */
        .verification-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none; /* Initially hidden */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        /* New Styles for the animation from the second code */
        .page-thunder-to-text {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .text-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            box-sizing: border-box;
            max-width: 100%;
            overflow: hidden;
        }

        /* Adjust font size for smaller screens */
        @media (max-width: 600px) {
            .text-container h1 {
                font-size: 24px;
            }
            .text-container h2 {
                font-size: 18px;
            }
        }
        
        /* --- Cursor Effect Styles --- */
        :root {
            --black: #252423;
            --white: #F6F4F2;
            --white-2: #FFF;
            --grey: #b8b6b3;
            --red: #FF4B4B;
            --orange: #FF8F42;
            --lightorange: #FFC730;
            --yellow: #F6FF56;
            --citrus: #A4FF4F;
            --green: #18FF74;
            --darkgreen: #00D672;
            --turquoise: #3CFFEC;
            --skyblue: #61C3FF;
            --kingblue: #5A87FF;
            --lavender: #8453E3;
            --purple: #C26EFF;
            --pink: #FB89FB;
            --input-border-radius: .25rem;
        }
        
        *, *:before, *:after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            border: 0;
            font: inherit;
            vertical-align: baseline;
        }
        
        #creature-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0;
            left: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            z-index: -1; /* This is the key change to keep it in the background */
        }
        
        #creature {
            font-size: .2vh;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 150em;
            height: 150em;
            flex-wrap: wrap;
        }
        
        #creature div {
            transform-style: preserve-3d;
            position: relative;
            width: 4em;
            height: 4em;
            margin: 3em;
            border-radius: 2em;
            will-change: transform;
            mix-blend-mode: plus-lighter;
            background: var(--red);
        }
    </style>
</head>
<body>

    <div id="creature-wrapper">
        <div id="creature"></div>
    </div>

    <div class="grid-bg"></div>

    <div class="portal-container" id="portalContainer">
        <div class="spiral-wave"></div>
    </div>
    
    <div class="portal-content" id="portalContent">
        <button class="teleport-btn" onclick="activateTeleportation()">TELEPORT TO EKANT'S SECRET BASE</button>
    </div>

    <div class="verification-overlay" id="verificationOverlay">
        <div class="page page-thunder-to-text">
            <div class="text-container">
                <canvas id="canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        function activateTeleportation() {
            // Hide the original portal content
            document.getElementById('portalContainer').style.display = 'none';
            document.getElementById('portalContent').style.display = 'none';
            
            // Hide the creature effect
            const creatureWrapper = document.getElementById('creature-wrapper');
            if (creatureWrapper) {
                creatureWrapper.style.display = 'none';
            }
            
            // Remove the cursor effect script to free up resources
            const cursorScript = document.getElementById('cursor-script');
            if (cursorScript) {
                cursorScript.remove();
            }
            
            // Show the new verification overlay
            const overlay = document.getElementById('verificationOverlay');
            overlay.style.display = 'flex';

            // Start the new animation
            startVerificationAnimation();
        }

        function startVerificationAnimation() {
            let canvas, ctx, w, h, thunder, textLines, particles;

            function Thunder(options) {
                options = options || {};
                // Reduced lifespan and max segments for better performance
                this.lifespan = options.lifespan || Math.round(Math.random() * 5 + 5); 
                this.maxlife = this.lifespan;
                this.color = options.color || '#fefefe';
                this.glow = options.glow || '#2323fe';
                this.x = options.x || Math.random() * w;
                this.y = options.y || Math.random() * h;
                this.width = options.width || 1; // Smaller line width
                this.direct = options.direct || Math.random() * Math.PI * 2;
                this.max = options.max || Math.round(Math.random() * 10 + 10); // Reduced segments
                this.segments = [...new Array(this.max)].map(() => {
                    return {
                        direct: this.direct + (Math.PI * Math.random() * 0.2 - 0.1),
                        length: Math.random() * 10 + 40, // Shorter length
                        change: Math.random() * 0.04 - 0.02
                    };
                });
                this.update = function (index, array) {
                    this.segments.forEach(s => {
                        (s.direct += s.change) && Math.random() > 0.96 && (s.change *= -1);
                    });
                    this.lifespan > 0 && this.lifespan-- || this.remove(index, array);
                };
                this.render = function (ctx) {
                    if (this.lifespan <= 0) return;
                    ctx.beginPath();
                    ctx.globalAlpha = this.lifespan / this.maxlife;
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.width;
                    ctx.shadowBlur = 16; // Reduced shadow blur
                    ctx.shadowColor = this.glow;
                    ctx.moveTo(this.x, this.y);
                    let prev = { x: this.x, y: this.y };
                    this.segments.forEach(s => {
                        const x = prev.x + Math.cos(s.direct) * s.length;
                        const y = prev.y + Math.sin(s.direct) * s.length;
                        prev = { x: x, y: y };
                        ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                    ctx.closePath();
                    ctx.shadowBlur = 0;
                    const strength = Math.random() * 40 + 20; // Reduced strength
                    const light = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, strength);
                    light.addColorStop(0, 'rgba(250, 200, 50, 0.6)');
                    light.addColorStop(0.1, 'rgba(250, 200, 50, 0.2)');
                    light.addColorStop(0.4, 'rgba(250, 200, 50, 0.06)');
                    light.addColorStop(0.65, 'rgba(250, 200, 50, 0.01)');
                    light.addColorStop(0.8, 'rgba(250, 200, 50, 0)');
                    ctx.beginPath();
                    ctx.fillStyle = light;
                    ctx.arc(this.x, this.y, strength, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                };
                this.remove = function (index, array) { array.splice(index, 1); };
            }

            function Spark(options) {
                options = options || {};
                this.x = options.x || w * 0.5;
                this.y = options.y || h * 0.5;
                this.v = options.v || { direct: Math.random() * Math.PI * 2, weight: Math.random() * 8 + 1, friction: 0.88 }; // Reduced weight
                this.a = options.a || { change: Math.random() * 0.4 - 0.2, min: this.v.direct - Math.PI * 0.4, max: this.v.direct + Math.PI * 0.4 };
                this.g = options.g || { direct: Math.PI * 0.5 + (Math.random() * 0.4 - 0.2), weight: Math.random() * 0.15 + 0.15 }; // Reduced gravity
                this.width = options.width || Math.random() * 2;
                this.lifespan = options.lifespan || Math.round(Math.random() * 10 + 20); // Reduced lifespan
                this.maxlife = this.lifespan;
                this.color = options.color || '#feca32';
                this.prev = { x: this.x, y: this.y };
                this.update = function (index, array) {
                    this.prev = { x: this.x, y: this.y };
                    this.x += Math.cos(this.v.direct) * this.v.weight;
                    this.x += Math.cos(this.g.direct) * this.g.weight;
                    this.y += Math.sin(this.v.direct) * this.v.weight;
                    this.y += Math.sin(this.g.direct) * this.g.weight;
                    this.v.weight > 0.2 && (this.v.weight *= this.v.friction);
                    this.v.direct += this.a.change;
                    (this.v.direct > this.a.max || this.v.direct < this.a.min) && (this.a.change *= -1);
                    this.lifespan > 0 && this.lifespan--;
                    this.lifespan <= 0 && this.remove(index, array);
                };
                this.render = function (ctx) {
                    if (this.lifespan <= 0) return;
                    ctx.beginPath();
                    ctx.globalAlpha = this.lifespan / this.maxlife;
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.width;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.prev.x, this.prev.y);
                    ctx.stroke();
                    ctx.closePath();
                };
                this.remove = function (index, array) { array.splice(index, 1); };
            }

            function Particles(options) {
                options = options || {};
                this.max = options.max || Math.round(Math.random() * 5 + 5); // Reduced number of sparks
                this.sparks = [...new Array(this.max)].map(() => new Spark(options));
                this.update = function () { this.sparks.forEach((s, i) => s.update(i, this.sparks)); };
                this.render = function (ctx) { this.sparks.forEach(s => s.render(ctx)); };
            }

            let animationComplete = false;
            let completionTimeout;
            let currentLineIndex = 0;
            let currentTextProgress = 0;

            function Text(options) {
                options = options || {};
                const pool = document.createElement('canvas');
                const buffer = pool.getContext('2d');
                this.size = options.size || 80;
                this.copy = options.copy || `INITIATING`;
                this.color = options.color || '#cd96fe';
                buffer.font = `bold ${this.size}px Orbitron`;
                this.bound = buffer.measureText(this.copy);
                this.bound.height = this.size * 1.5;
                pool.width = this.bound.width;
                pool.height = this.bound.height;
                buffer.font = `bold ${this.size}px Orbitron`;
                buffer.strokeStyle = this.color;
                buffer.strokeText(this.copy, 0, this.bound.height * 0.8);
                this.data = buffer.getImageData(0, 0, this.bound.width, this.bound.height);
                this.x = options.x || w * 0.5 - this.bound.width * 0.5;
                this.y = options.y || h * 0.5 - this.size * 0.5;

                this.update = function() {
                    let done = false;
                    for (let j = 0; j < 5; j++) { // Process 5 columns at a time for efficiency
                        if (currentTextProgress >= this.bound.width) {
                            done = true;
                            break;
                        }
                        for (let i = 0; i < this.bound.height; i++) {
                            const pixelIndex = (i * this.bound.width + currentTextProgress) * 4;
                            const alpha = this.data.data[pixelIndex + 3];
                            if (alpha > 0 && Math.random() > 0.98) { // Reduced spawn chance
                                const x = this.x + currentTextProgress;
                                const y = this.y + i;
                                thunder.push(new Thunder({ x: x, y: y }));
                                Math.random() > 0.8 && particles.push(new Particles({ x: x, y: y }));
                            }
                        }
                        currentTextProgress++;
                    }
                    return done;
                };

                this.render = function (ctx) {
                    ctx.putImageData(this.data, this.x, this.y, 0, 0, currentTextProgress, this.bound.height);
                };
            }

            function loop() {
                update();
                render();
                if (!animationComplete) {
                    requestAnimationFrame(loop);
                }
            }

            function update() {
                if (currentLineIndex < textLines.length) {
                    const lineComplete = textLines[currentLineIndex].update();
                    if (lineComplete) {
                        currentLineIndex++;
                        currentTextProgress = 0;
                    }
                } else {
                    if (!animationComplete) {
                        animationComplete = true;
                        completionTimeout = setTimeout(() => {
                            window.location.href = 'base.html';
                        }, 500); 
                    }
                }

                thunder.forEach((l, i) => l.update(i, thunder));
                particles.forEach(p => p.update());
            }

            function render() {
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'screen';
                
                textLines.forEach(line => line.render(ctx));
                
                thunder.forEach(l => l.render(ctx));
                particles.forEach(p => p.render(ctx));
            }

            (function () {
                canvas = document.getElementById('canvas');
                canvas.style.display = 'block'; 
                ctx = canvas.getContext('2d');
                w = window.innerWidth;
                h = window.innerHeight;
                canvas.width = w;
                canvas.height = h;

                thunder = [];
                particles = [];
                
                // Dynamically adjust font size based on screen width
                const baseSize = 80;
                const size = w < 600 ? baseSize * 0.6 : baseSize;
                const lineHeight = size * 1.2;

                const text1 = 'INITIATING';
                const text2 = 'VERIFICATION';

                const textLine1 = new Text({ 
                    copy: text1, 
                    size: size, 
                    y: (h - (lineHeight * 2)) / 2, 
                    x: (w - (size * text1.length / 2)) / 2 // Simple width estimate
                });
                const textLine2 = new Text({ 
                    copy: text2, 
                    size: size, 
                    y: (h - (lineHeight * 2)) / 2 + lineHeight,
                    x: (w - (size * text2.length / 2)) / 2
                });
                
                textLines = [textLine1, textLine2];

                loop();
            })();
        }
    </script>

    <script type="module" id="cursor-script">
        import { animate, createTimeline, createTimer, stagger, utils } from './anime.esm.js';

        const creatureEl = document.querySelector('#creature');
        const viewport = { w: window.innerWidth * .5, h: window.innerHeight * .5 };
        const cursor = { x: 0, y: 0 };
        const rows = 13;
        const grid = [rows, rows];
        const from = 'center';
        const scaleStagger = stagger([2, 5], { ease: 'inQuad', grid, from });
        const opacityStagger = stagger([1, .1], { grid, from });
        
        for (let i = 0; i < (rows * rows); i++) {
          creatureEl.appendChild(document.createElement('div'));
        }
        
        const particuleEls = creatureEl.querySelectorAll('div');
        
        utils.set(creatureEl, {
          width: rows * 10 + 'em',
          height: rows * 10 + 'em'
        });
        
        utils.set(particuleEls, {
          x: 0,
          y: 0,
          scale: scaleStagger,
          opacity: opacityStagger,
          background: stagger([80, 20], { grid, from,
            modifier: v => `hsl(4, 70%, ${v}%)`,
          }),
          boxShadow: stagger([8, 1], { grid, from,
            modifier: v => `0px 0px ${utils.round(v, 0)}em 0px var(--red)`,
          }),
          zIndex: stagger([rows * rows, 1], { grid, from, modifier: utils.round(0) }),
        });
        
        const pulse = () => {
          animate(particuleEls, {
            keyframes: [
              {
                scale: 5,
                opacity: 1,
                delay: stagger(90, { start: 1650, grid, from }),
                duration: 150,
              }, {
                scale: scaleStagger,
                opacity: opacityStagger,
                ease: 'inOutQuad',
                duration: 600
              }
            ],
          });
        }
        
        const mainLoop = createTimer({
          frameRate: 15, // Animate to the new cursor position every 250ms
          onUpdate: () => {
            animate(particuleEls, {
              x: cursor.x,
              y: cursor.y,
              delay: stagger(40, { grid, from }),
              duration: stagger(120, { start: 750, ease: 'inQuad', grid, from }),
              ease: 'inOut',
              composition: 'blend', // This allows the animations to overlap nicely
            });
          }
        });
        
        const autoMove = createTimeline()
        .add(cursor, {
          x: [-viewport.w * .45, viewport.w * .45],
          modifier: x => x + Math.sin(mainLoop.currentTime * .0007) * viewport.w * .5,
          duration: 3000,
          ease: 'inOutExpo',
          alternate: true,
          loop: true,
          onBegin: pulse,
          onLoop: pulse,
        }, 0)
        .add(cursor, {
          y: [-viewport.h * .45, viewport.h * .45],
          modifier: y => y + Math.cos(mainLoop.currentTime * .00012) * viewport.h * .5,
          duration: 1000,
          ease: 'inOutQuad',
          alternate: true,
          loop: true,
        }, 0);
        
        const manualMovementTimeout = createTimer({
          duration: 1500,
          onComplete: () => autoMove.play(),
        });
        
        const followPointer = e => {
          const event = e.type === 'touchmove' ? e.touches[0] : e;
          cursor.x = event.pageX - viewport.w;
          cursor.y = event.pageY - viewport.h;
          autoMove.pause();
          manualMovementTimeout.restart();
        }
        
        document.addEventListener('mousemove', followPointer);
        document.addEventListener('touchmove', followPointer);
    </script>
</body>
</html>
